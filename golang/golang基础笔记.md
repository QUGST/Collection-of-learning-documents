go语言背景

### 用途

Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。

对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。

## Go 语言最主要的特性：

- 自动垃圾回收
- 更丰富的内置类型
- 函数多返回值
- 错误处理
- 匿名函数和闭包
- 类型和接口
- 并发编程
- 反射
- 语言交互性

## Go 语言的基础组成有以下几个部分：

- 包声明

你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。

- 引入包

import "fmt" 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。

- 函数

main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。

- 变量

当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。

- 语句 & 表达式

fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 使用 fmt.Print("hello, world\n") 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。

- 注释

单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* _开头，并以_ */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。

# 基础语法

## 行分割符

在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。

如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中并不鼓励这种做法。

## 注释

注释不会被编译，每一个包应该有相关注释。

单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以\*/ 结尾。

## 标识符

标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。标识符

## 字符串连接

Go 语言的字符串连接可以通过 + 实现

## 数据类型

### 1 布尔型

布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。

### 2 数字类型

整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。

### 3 字符串类型:

字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。

### 4 派生类型:

包括： (a) 指针类型（Pointer） (b) 数组类型 (c) 结构化类型(struct) (d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface） (h) Map 类型

### 数字类型

1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)

### 浮点类型

1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数

### 其他数字类型

1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针

## 变量

### 变量分类

局部变量：在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

全局变量：在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。

备注：

1.局部变量不会一直存在，在函数被调用时存在，函数调用结束后变量就会被销毁，即生命周期。

2.Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。

### 变量声明

#### 指定变量类型

声明变量的一般形式是使用 var 关键字：

****var identifier type****

一次声明多个变量：

****var identifier1, identifier2 type****

指定变量类型，如果没有初始化，则变量默认为零值。

#### 自行判定变量类型

var v_name = value

#### 快捷声明

v_name := value

如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误

#### 多变量声明

//****类型相同****多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3

var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断

vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误

// 这种因式分解关键字的写法一般用于声明全局变量 var ( vname1 v_type1 vname2 v_type2 )

## 常量

常量是一个简单值的标识符，在程序运行时，不会被修改的量。

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：

### 常量声明

const identifier [type] = value

#### 显式类型定义： const b string = "abc"

#### 隐式类型定义： const b = "abc"

#### 枚举

const ( Unknown = 0 Female = 1 Male = 2 )

### iota

iota，特殊常量，可以认为是一个可以被编译器修改的常量。

iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

iota 只是在同一个 const 常量组内递增，每当有新的 const 关键字时，iota 计数会重新开始

****在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。****

iota 可以被用作枚举值：

简写为

奇怪的例子

i= 1 j= 6 k= 12 l= 24

iota 表示从 0 开始自动加 1，所以 i=1<<0, j=3<<1（<< 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 k=3<<2，l=3<<3。

## 作用域

Go 语言中变量可以在三个地方声明：

****函数内定义的变量称为局部变量****

*_在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。_*

****函数外定义的变量称为全局变量****

*_在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。全局变量可以在任何函数中使用。_*

****函数定义中的变量称为形式参数****

*_形式参数会作为函数的局部变量来使用。_*

****可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。****

## 运算符

假定 A 值为 10，B 值为 20。

### 算术运算符

\+ 相加 A + B 输出结果 30

\- 相减 A - B 输出结果 -10

\* 相乘 A * B 输出结果 200

/ 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9

### 关系运算符

\== 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True

\> 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A > B) 为 False < 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A < B) 为 True = 检查左边值是否大于等于右边值，是返回 True 否返回 False。 (A >= B) 为 False <= 检查左边值是否小于等于右边值，是返回 True 否返回 False。 (A <= B) 为 True

### 逻辑运算符

假定 A 值为 True，B 值为 False

&& 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A && B) 为 False || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A || B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A && B) 为 True

### 位运算符

假定 A 为60，B 为13：

& 按位与运算符"&"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A & B) 结果为 12, 二进制为 0000 1100 | 按位或运算符"|"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A | B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符"^"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 << 左移运算符"<<"是双目运算符。左移n位就是乘以2的n次方。 其功能把"<<"左边的运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 A << 2 结果为 240 ，二进制为 1111 0000

\>> 右移运算符">>"是双目运算符。右移n位就是除以2的n次方。 其功能是把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数。 A >> 2 结果为 15 ，二进制为 0000 1111

### 赋值运算符

= 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *_= 相乘后再赋值 C_ *= A 等于 C = C * A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A <<= 左移后赋值 C <<= 2 等于 C = C << 2

\>>= 右移后赋值 C >>= 2 等于 C = C >> 2 &= 按位与后赋值 C &= 2 等于 C = C & 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 |= 按位或后赋值 C |= 2 等于 C = C | 2

### 其他运算符

& 返回变量存储地址 &a; 将给出变量的实际地址。

\* 指针变量。 *a; 是一个指针变量

## 基础控制语句

### if else

### switch

switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。

#### fallthrough

使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。

#### default

switch 的 default 不论放在哪都是最后执行：

变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。

您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。

### Type Switch

switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。

### select

select 是 Go 中的一个控制结构，类似于 switch 语句。

select 语句只能用于通道操作，每个 case 必须是一个通道操作，要么是发送要么是接收。

select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。

如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码。

每个 case 都必须是一个通道 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通道可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，select 会随机公平地选出一个执行，其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通道可以运行；Go 不会重新对 channel 或值进行求值。

### for循环

和cpp的for一样

和cpp的while一样

无限循环

for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：

以上代码中的 key 和 value 是可以省略。

如果只想读取 key，格式如下：

或者只读value。

### break

用于循环语句中跳出循环，并开始执行循环之后的语句。 break 在 switch 语句中在执行一条 case 后跳出语句的作用。 break 可应用在 select 语句中。

<u>*_在 Go 语言中，break 语句在 select 语句中的应用是相对特殊的。由于 select 语句的特性，break 语句并不能直接用于跳出 select 语句本身，因为 select 语句是非阻塞的，它会一直等待所有的通信操作都准备就绪。如果需要提前结束 select 语句的执行，可以使用 return 或者 goto 语句来达到相同的效果。_*</u>

在多重循环中，可以用标号 label 标出想 break 的循环，直接跳出多个循环

### continue

for 循环中，执行 continue 语句会触发 for 增量语句的执行。

在多重循环中，可以用标号 label 标出想 continue 的循环。

### goto

Go 语言的 goto 语句可以无条件地转移到过程中指定的行。

goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。

但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。

## 函数

Go 语言最少有个 main() 函数。

你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。

函数声明告诉了编译器函数的名称，返回类型，和参数。

****func****：函数由 func 开始声明 ****function_name****：函数名称，参数列表和返回值类型构成了函数签名。 ****parameter list****：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 ****return_types****：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 ****函数体****：函数定义的代码集合。

### Go 函数可以返回多个值

### 值传递

和cpp一样

### 引用传递

### 函数作为参数传递

### 闭包（匿名函数）

Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。

匿名函数是一种没有函数名的函数，通常用于在函数内部定义函数，或者作为函数参数进行传递。

#### 带参数的闭包函数调用

可以实现闭包函数调用次数的记录

### 方法

一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。就是自定义数据结构的函数

关于值和指针，如果想在方法中改变结构体类型的属性，需要对方法传递指针

## 数组

### 声明数组

在 Go 语言中，数组的大小是类型的一部分，因此不同大小的数组是不兼容的，也就是说 [5]int 和 [10]int 是不同的类型

如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度：

如果设置了数组的长度，我们还可以通过指定下标来初始化元素：

### 函数传递数组

## 指针

一个指针变量指向了一个值的内存地址。

类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：

var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。

### 空指针

当一个指针被定义后没有分配到任何变量时，它的值为 nil。

nil 指针也称为空指针。

nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。

一个指针变量通常缩写为 ptr。

### 指针数组

### 指向指针的指针

### 函数指针形参

## 结构体

结构体定义

变量声明

访问结构体成员

使用结构体指针访问结构体成员，使用 "." 操作符

结构体中属性的首字母大小写问题

首字母大写相当于 public。 首字母小写相当于 private。 注意: 这个 public 和 private 是相对于包（go 文件首行的 package 后面跟的包名）来说的。

当要将结构体对象转换为 JSON 时，对象中的属性首字母必须是大写，才能正常转换为 JSON。

## 切片

Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片("动态数组")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

### 切片定义

### 切片初始化

### len() 和 cap() 函数

切片是可索引的，并且可以由 len() 方法获取长度。

切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。

基于原数组或者切片创建一个新的切片后，对于底层数组容量是 k 的切片 slice[i:j] 来说：长度: j-i 容量: k-i

### 空(nil)切片

一个切片在未初始化之前默认为 nil，长度为 0

### 切片截取

可以通过设置下限及上限来设置截取切片 [lower-bound:upper-bound]

### append() 和 copy() 函数

如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。

### 在做函数调用时，slice 按引用传递，array 按值传递

## 范围(Range)

Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。

for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：

Go 中的中文采用 UTF-8 编码，因此逐个遍历字符时必须采用 for-range 形式

## 集合(Map)

Map 是一种无序的键值对的集合。

Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。

Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，遍历 Map 时返回的键值对的顺序是不确定的。

在获取 Map 的值时，如果键不存在，返回该类型的零值，例如 int 类型的零值是 0，string 类型的零值是 ""。

Map 是引用类型，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量。

其中 KeyType 是键的类型，ValueType 是值的类型，initialCapacity 是可选的参数，用于指定 Map 的初始容量。Map 的容量是指 Map 中可以保存的键值对的数量，当 Map 中的键值对数量达到容量时，Map 会自动扩容。如果不指定 initialCapacity，Go 语言会根据实际情况选择一个合适的值。

## 类型转换

go 不支持隐式转换类型

### 数值类型转换

### 字符串类型转换

strconv.Atoi 函数返回两个值，第一个是转换后的整型值，第二个是可能发生的错误，我们可以使用空白标识符 _ 来忽略这个错误

### 接口类型转换

接口类型转换有两种情况：类型断言和类型转换。

类型断言用于将接口类型转换为指定类型，其语法为：

其中 value 是接口类型的变量，type 或 T 是要转换成的类型。

如果类型断言成功，它将返回转换后的值和一个布尔值，表示转换是否成功。

型转换用于将一个接口类型的值转换为另一个接口类型，其语法为：

T 是目标接口类型，value 是要转换的值。

在类型转换中，我们必须保证要转换的值和目标接口类型之间是兼容的，否则编译器会报错。

## 接口

Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。

接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。

Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。

如果想要通过接口方法修改属性，需要在传入指针的结构体才行

## 错误处理

Go 语言通过内置的错误接口提供了非常简单的错误处理机制。

error 类型是一个接口类型，这是它的定义：

我们可以在编码中通过实现 error 接口类型来生成错误信息。

函数通常在最后的返回值中返回错误信息。使用 errors.New 可返回一个错误信息：

### panic 与 recover

panic 与 recover 是 Go 的两个内置函数，这两个内置函数用于处理 Go 运行时的错误，panic 用于主动抛出错误，recover 用来捕获 panic 抛出的错误。

****引发panic有两种情况****，一是程序主动调用，二是程序产生运行时错误，由运行时检测并退出。 ****panic作用****是终止当前正在运行的程序（包括所有协程）并输出导致异常的堆栈信息。在遇到无法处理的异常情况时，例如比如数组越界、操作未初始化的map、空指针等都会触发panic。主动触发panic示例：

****recover****可以让触发了panic的程序继续运行，recover仅在延迟函数defer中有效，在正常的执行过程中，调用recover会返回nil并且不产生其他任何效果。如果当前的goroutine触发了panic，调用recover可以捕获到panic的输入值，并且恢复正常运行。

发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或运行到最外层函数。 panic不但可以在函数正常流程中抛出，在defer逻辑里也可以再次调用panic或抛出panic。defer里面的panic能够被后续执行的defer捕获。 recover用来捕获panic，阻止panic继续向上传递。recover()和defer一起使用，但是defer只有在后面的函数体内直接被掉用才能捕获panic来终止异常，否则返回nil，异常继续向外传递。

# Go 并发

## go

Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。

goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 同一个程序中的所有 goroutine 共享同一个地址空间。

goroutine 语法格式：

## 通道（channel）

通道（channel）是用来传递数据的一个数据结构。

通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 <- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。

通道遵循先进先出原则。

不带缓冲区的通道在向通道发送值时，必须及时接收，且必须一次接收完成。

声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：

### 通道缓冲区

通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：

带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。

不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。

注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞

### Go 遍历通道与关闭通道

Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片

如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。

关闭通道并不会丢失里面的数据，只是让读取通道数据的时候不会读完之后一直阻塞等待新数据写入

chan不需要显示关闭(close)，只要没有goroutine持有channel，相关资源会自动释放。

chan最好是发送端调用close，此时读取端会收到一个空消息